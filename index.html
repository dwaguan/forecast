<script type="module">
    // Import Firebase SDK
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
    import { getDatabase, ref, push, onValue, set, get } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js';

    // Firebase Configuration
    const firebaseConfig = {
        apiKey: "AIzaSyQtsgh6G5TLqk_EgfyA9tIWvxnzGlpdy",
        authDomain: "forecast-fab55.firebaseapp.com",
        databaseURL: "https://forecast-fab55-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "forecast-fab55",
        storageBucket: "forecast-fab55.appspot.com",
        messagingSenderId: "497238817189",
        appId: "1:497238817189:web:ec3f5f5818e8fd2c24a4c",
        measurementId: "G-T3BQTY3FL"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);

    // Global state
    let allPredictions = [];
    let predictionKeys = {}; // Map of prediction id to Firebase key
    let myPredictions = JSON.parse(localStorage.getItem('myPredictions')) || [];
    let currentUser = localStorage.getItem('forecast-user-id') || ('user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9));
    let currentTab = 'feed';

    document.addEventListener('DOMContentLoaded', () => {
        localStorage.setItem('forecast-user-id', currentUser);
        setupEventListeners();
        loadPredictions();
        switchTab('feed');
        const loadingOverlay = document.getElementById('loading-overlay');
        if (loadingOverlay) loadingOverlay.style.display = 'none';
    });

    function setupEventListeners() {
        const form = document.getElementById('public-prediction-form');
        if (form) form.addEventListener('submit', handlePredictionSubmit);
        const confidenceSlider = document.getElementById('confidence');
        const confidenceValue = document.getElementById('confidence-value');
        if (confidenceSlider && confidenceValue) {
            confidenceSlider.addEventListener('input', () => confidenceValue.textContent = `${confidenceSlider.value}%`);
        }
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tabMap = {
                    'ğŸŒ å…¨çƒé¢„æµ‹': 'feed',
                    'â• å‘å¸ƒé¢„æµ‹': 'create',
                    'ğŸ“ æˆ‘çš„é¢„æµ‹': 'my'
                };
                switchTab(tabMap[btn.textContent.trim()]);
            });
        });
        // Add change listeners for filters
        ['category-filter', 'status-filter', 'sort-filter'].forEach(id => {
            const element = document.getElementById(id);
            if (element) element.addEventListener('change', filterPredictions);
        });
    }

    function setDefaultDate() {
        const dueDateInput = document.getElementById('due-date');
        if (dueDateInput) {
            const tomorrow = new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            dueDateInput.valueAsDate = tomorrow;
            dueDateInput.min = new Date().toISOString().split('T')[0];
        }
    }

    function loadPredictions() {
        const predictionsRef = ref(database, 'predictions');
        onValue(predictionsRef, (snapshot) => {
            const data = snapshot.val() || {};
            allPredictions = [];
            predictionKeys = {};
            Object.entries(data).forEach(([key, pred]) => {
                pred.id = pred.id || Date.now().toString(); // Ensure id exists
                allPredictions.push(pred);
                predictionKeys[pred.id] = key;
            });
            allPredictions.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
            document.getElementById('global-predictions').classList.remove('loading');
            updateStats();
            if (currentTab === 'feed') displayPredictions();
            if (currentTab === 'my') displayMyPredictions();
        }, (error) => {
            console.error('Error loading predictions:', error);
            document.getElementById('global-predictions').innerHTML = 'âŒ æ•°æ®åŠ è½½å¤±è´¥ã€‚';
        });
    }

    function savePrediction(prediction) {
        const newRef = push(ref(database, 'predictions'), prediction);
        return get(newRef).then(snapshot => {
            const key = snapshot.key;
            predictionKeys[prediction.id] = key;
            return true;
        }).catch(error => {
            console.error('Error saving prediction:', error);
            alert('ä¿å­˜é¢„æµ‹å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œæˆ–æƒé™ï¼');
            return false;
        });
    }

    function handlePredictionSubmit(e) {
        e.preventDefault();
        const submitBtn = document.getElementById('submit-btn');
        if (!submitBtn) return;
        submitBtn.disabled = true;
        submitBtn.textContent = 'å‘å¸ƒä¸­...';

        const username = document.getElementById('username')?.value.trim() || 'åŒ¿åç”¨æˆ·';
        const content = document.getElementById('content')?.value.trim();
        const dueDate = document.getElementById('due-date')?.value;
        const category = document.getElementById('category')?.value;
        const confidence = parseInt(document.getElementById('confidence')?.value || 50);

        if (!content || !dueDate) {
            alert('è¯·å¡«å†™é¢„æµ‹å†…å®¹å’Œæˆªæ­¢æ—¥æœŸï¼');
            submitBtn.disabled = false;
            submitBtn.textContent = 'ğŸš€ å‘å¸ƒåˆ°å…¨çƒ';
            return;
        }

        const newPrediction = {
            id: Date.now().toString(),
            content, dueDate, category, confidence, username,
            userId: currentUser, createdAt: new Date().toISOString(),
            verified: false, result: null, verifiedAt: null,
            likes: [], likesCount: 0
        };

        savePrediction(newPrediction).then(success => {
            if (success) {
                if (!allPredictions.some(p => p.id === newPrediction.id)) {
                    allPredictions.unshift(newPrediction);
                }
                if (!myPredictions.some(p => p.id === newPrediction.id)) {
                    myPredictions.unshift(newPrediction);
                }
                localStorage.setItem('myPredictions', JSON.stringify(myPredictions));
                e.target.reset();
                setDefaultDate();
                document.getElementById('confidence').value = '50';
                document.getElementById('confidence-value').textContent = '50%';
                updateStats();
                if (currentTab === 'feed') displayPredictions();
                if (currentTab === 'my') displayMyPredictions();
                switchTab('feed');
                alert('ğŸ‰ é¢„æµ‹å·²æˆåŠŸå‘å¸ƒåˆ°å…¨çƒå¹³å°ï¼');
            }
            submitBtn.disabled = false;
            submitBtn.textContent = 'ğŸš€ å‘å¸ƒåˆ°å…¨çƒ';
        });
    }

    function switchTab(tabName) {
        currentTab = tabName;
        document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
        const activeBtn = document.querySelector(`.tab-btn[onclick="switchTab('${tabName}')"]`);
        if (activeBtn) activeBtn.classList.add('active');
        document.querySelectorAll('.tab-content').forEach(content => content.style.display = 'none');
        const tabContent = document.getElementById(`${tabName}-tab`);
        if (tabContent) tabContent.style.display = 'block';
        else console.error(`Tab content ${tabName}-tab not found`);
        if (tabName === 'feed') displayPredictions();
        else if (tabName === 'my') displayMyPredictions();
    }

    function updateStats() {
        const total = allPredictions.length;
        const verified = allPredictions.filter(p => p.verified).length;
        const today = new Date().toISOString().split('T')[0];
        const todayCount = allPredictions.filter(p => p.createdAt.split('T')[0] === today).length;
        document.getElementById('total-predictions').textContent = total;
        document.getElementById('verified-predictions').textContent = verified;
        document.getElementById('today-predictions').textContent = todayCount;
    }

    function displayPredictions() {
        const container = document.getElementById('global-predictions');
        if (!container) return;
        if (allPredictions.length === 0) {
            container.innerHTML = 'ğŸ“­ è¿˜æ²¡æœ‰é¢„æµ‹ï¼Œæˆä¸ºç¬¬ä¸€ä¸ªå‘å¸ƒé¢„æµ‹çš„äººå§ï¼';
            return;
        }
        const filteredAndSorted = filterAndSortPredictions(allPredictions);
        container.innerHTML = filteredAndSorted.map(pred => createPredictionHTML(pred, true)).join('');
    }

    function displayMyPredictions() {
        const container = document.getElementById('my-predictions');
        if (!container) return;
        const myPreds = myPredictions.filter(p => p.userId === currentUser);
        if (myPreds.length === 0) {
            container.innerHTML = 'ğŸ“ ä½ è¿˜æ²¡æœ‰å‘å¸ƒä»»ä½•é¢„æµ‹';
            return;
        }
        container.innerHTML = myPreds.map(pred => createPredictionHTML(pred, false)).join('');
    }

    function filterAndSortPredictions(predictions) {
        const categoryFilter = document.getElementById('category-filter')?.value || '';
        const statusFilter = document.getElementById('status-filter')?.value || '';
        const sortFilter = document.getElementById('sort-filter')?.value || 'newest';
        let filtered = [...predictions];
        if (categoryFilter) filtered = filtered.filter(p => p.category === categoryFilter);
        if (statusFilter) filtered = filtered.filter(p => getStatus(p) === statusFilter);
        switch (sortFilter) {
            case 'oldest': filtered.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt)); break;
            case 'likes': filtered.sort((a, b) => (b.likesCount || 0) - (a.likesCount || 0)); break;
            case 'confidence': filtered.sort((a, b) => b.confidence - a.confidence); break;
            case 'newest': default: filtered.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)); break;
        }
        return filtered;
    }

    function filterPredictions() {
        if (currentTab === 'feed') displayPredictions();
    }

    function getStatus(prediction) {
        if (prediction.verified) return 'verified';
        const today = new Date().toISOString().split('T')[0];
        const dueDate = prediction.dueDate;
        if (dueDate === today) return 'due';
        if (dueDate < today) return 'overdue';
        return 'pending';
    }

    function createPredictionHTML(pred, showPublicActions) {
        const status = getStatus(pred);
        const statusText = { 'pending': 'æœªåˆ°æœŸ', 'due': 'ä»Šæ—¥åˆ°æœŸ', 'overdue': 'å·²è¿‡æœŸ', 'verified': pred.result ? 'é¢„æµ‹æˆåŠŸ' : 'é¢„æµ‹å¤±è´¥' };
        const statusClass = { 'pending': 'status-pending', 'due': 'status-today', 'overdue': 'status-overdue', 'verified': pred.result ? 'status-success' : 'status-fail' };
        const categoryIcons = { 'finance': 'ğŸ“ˆ', 'politics': 'ğŸ›ï¸', 'sports': 'âš½', 'tech': 'ğŸš€', 'climate': 'ğŸŒ¡ï¸', 'other': 'ğŸŒŸ' };
        const isLiked = pred.likes?.includes(currentUser);
        const canVerify = !pred.verified && ['due', 'overdue'].includes(status) && pred.userId === currentUser;
        return `
            <div class="prediction-item">
                <h3>${pred.content}</h3>
                <div class="prediction-meta">
                    <span>ğŸ‘¤ <span class="username">${pred.username}</span></span>
                    <span>ğŸ“… æˆªæ­¢: ${formatDate(pred.dueDate)}</span>
                    <span>ğŸ¯ ä¿¡å¿ƒ: ${pred.confidence}%</span>
                    <span>${categoryIcons[pred.category] || 'ğŸŒŸ'} ${pred.category}</span>
                    <span>â° ${formatDateTime(pred.createdAt)}</span>
                </div>
                <div class="status-tag ${statusClass[status]}">${statusText[status]}</div>
                <div class="actions">
                    ${showPublicActions ? `<button class="like-btn ${isLiked ? 'liked' : ''}" onclick="toggleLike('${pred.id}')">â¤ï¸ ${pred.likesCount || 0}</button>` : ''}
                    ${canVerify ? `<button onclick="verifyPrediction('${pred.id}', true)" style="background: var(--success)">âœ… é¢„æµ‹æˆåŠŸ</button><button onclick="verifyPrediction('${pred.id}', false)" style="background: var(--danger)">âŒ é¢„æµ‹å¤±è´¥</button>` : ''}
                    ${pred.userId === currentUser ? `<button onclick="deletePrediction('${pred.id}')" style="background: #6c757d">ğŸ—‘ï¸ åˆ é™¤</button>` : ''}
                </div>
                ${pred.verified ? `<p style="margin-top: 10px; font-size: 14px; color: #6c757d;"><strong>éªŒè¯æ—¶é—´:</strong> ${formatDateTime(pred.verifiedAt)}</p>` : ''}
            </div>
        `;
    }

    function toggleLike(predictionId) {
        const prediction = allPredictions.find(p => p.id === predictionId);
        if (!prediction) return;
        const key = predictionKeys[predictionId];
        if (!key) {
            console.error('No Firebase key found for prediction:', predictionId);
            return;
        }
        if (!prediction.likes) prediction.likes = [];
        const userIndex = prediction.likes.indexOf(currentUser);
        if (userIndex === -1) {
            prediction.likes.push(currentUser);
            prediction.likesCount = (prediction.likesCount || 0) + 1;
        } else {
            prediction.likes.splice(userIndex, 1);
            prediction.likesCount = Math.max(0, (prediction.likesCount || 0) - 1);
        }
        const dbRef = ref(database, `predictions/${key}`);
        set(dbRef, prediction).then(() => {
            const index = allPredictions.findIndex(p => p.id === predictionId);
            if (index !== -1) allPredictions[index] = prediction;
            displayPredictions();
        }).catch(error => console.error('Error updating like:', error));
    }

    function verifyPrediction(predictionId, result) {
        const prediction = allPredictions.find(p => p.id === predictionId);
        if (!prediction || prediction.userId !== currentUser) return;
        const key = predictionKeys[predictionId];
        if (!key) {
            console.error('No Firebase key found for prediction:', predictionId);
            return;
        }
        prediction.verified = true;
        prediction.result = result;
        prediction.verifiedAt = new Date().toISOString();
        const dbRef = ref(database, `predictions/${key}`);
        set(dbRef, prediction).then(() => {
            const index = allPredictions.findIndex(p => p.id === predictionId);
            if (index !== -1) allPredictions[index] = prediction;
            myPredictions = myPredictions.map(p => p.id === predictionId ? prediction : p);
            localStorage.setItem('myPredictions', JSON.stringify(myPredictions));
            updateStats();
            displayPredictions();
            displayMyPredictions();
            alert(`å·²æ ‡è®°ä¸º${result ? 'æˆåŠŸ' : 'å¤±è´¥'}`);
        }).catch(error => console.error('Error verifying prediction:', error));
    }

    function deletePrediction(predictionId) {
        if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡é¢„æµ‹å—ï¼Ÿ')) return;
        const key = predictionKeys[predictionId];
        if (key) {
            const dbRef = ref(database, `predictions/${key}`);
            set(dbRef, null).then(() => {
                const index = allPredictions.findIndex(p => p.id === predictionId);
                if (index !== -1) allPredictions.splice(index, 1);
                myPredictions = myPredictions.filter(p => p.id !== predictionId);
                localStorage.setItem('myPredictions', JSON.stringify(myPredictions));
                updateStats();
                displayPredictions();
                displayMyPredictions();
            }).catch(error => console.error('Error deleting prediction:', error));
        }
    }

    function formatDate(dateString) {
        const date = new Date(dateString);
        return `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
    }

    function formatDateTime(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffHours = Math.floor((now - date) / (1000 * 60 * 60));
        if (diffHours < 1) return 'åˆšåˆš';
        if (diffHours < 24) return `${diffHours}å°æ—¶å‰`;
        if (diffHours < 48) return 'æ˜¨å¤©';
        return formatDate(dateString);
    }

    window.switchTab = switchTab;
    window.toggleLike = toggleLike;
    window.verifyPrediction = verifyPrediction;
    window.deletePrediction = deletePrediction;
</script>
